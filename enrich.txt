"""
Trade Data Enrichment Framework

A comprehensive framework for enriching trade datasets with reference data.
Supports multiple enrichment types with factory pattern and automatic registration.
"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Optional, Union, Tuple, Any
from collections import namedtuple
import pandas as pd
import numpy as np
import logging
from functools import wraps

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# =============================================================================
# CUSTOM EXCEPTIONS
# =============================================================================

class EnrichmentError(Exception):
    """Base exception for enrichment operations"""
    pass


class EnrichmentDataError(EnrichmentError):
    """Exception raised when enrichment data is invalid or missing"""
    pass


class EnrichmentProcessingError(EnrichmentError):
    """Exception raised during enrichment processing"""
    pass


class EnrichmentConfigurationError(EnrichmentError):
    """Exception raised for configuration issues"""
    pass


class ReferenceDataError(EnrichmentError):
    """Exception raised when reference data cannot be loaded"""
    pass


class RatingCalculationError(EnrichmentError):
    """Exception raised during rating calculations"""
    pass


# =============================================================================
# ENUMS AND NAMEDTUPLES
# =============================================================================

class RatingScale(Enum):
    """Normalized rating scale for all agencies"""
    AAA = 1
    AA_PLUS = 2
    AA = 3
    AA_MINUS = 4
    A_PLUS = 5
    A = 6
    A_MINUS = 7
    BBB_PLUS = 8
    BBB = 9
    BBB_MINUS = 10
    BB_PLUS = 11
    BB = 12
    BB_MINUS = 13
    B_PLUS = 14
    B = 15
    B_MINUS = 16
    CCC_PLUS = 17
    CCC = 18
    CCC_MINUS = 19
    CC = 20
    C = 21
    D = 22
    NR = 999  # Not Rated


class RatingAgency(Enum):
    """Rating agencies enumeration"""
    SP = "S&P"
    MOODY = "Moody's"
    FITCH = "Fitch"


class EnrichmentStatus(Enum):
    """Status of enrichment operation"""
    SUCCESS = "SUCCESS"
    PARTIAL = "PARTIAL"
    FAILED = "FAILED"
    NO_DATA = "NO_DATA"


# Named tuples for structured data
EnrichmentResult = namedtuple('EnrichmentResult', ['status', 'message', 'data'])
RatingInfo = namedtuple('RatingInfo', ['rating', 'agency', 'scale_value'])
RatingSummary = namedtuple('RatingSummary', [
    'average_rating', 'best_rating', 'worst_rating', 
    'best_agency', 'worst_agency', 'rating_count'
])

# =============================================================================
# RATING MAPPERS
# =============================================================================

class RatingMapper:
    """Maps agency-specific ratings to normalized scale"""
    
    def __init__(self):
        self._sp_mapping = {
            'AAA': RatingScale.AAA,
            'AA+': RatingScale.AA_PLUS,
            'AA': RatingScale.AA,
            'AA-': RatingScale.AA_MINUS,
            'A+': RatingScale.A_PLUS,
            'A': RatingScale.A,
            'A-': RatingScale.A_MINUS,
            'BBB+': RatingScale.BBB_PLUS,
            'BBB': RatingScale.BBB,
            'BBB-': RatingScale.BBB_MINUS,
            'BB+': RatingScale.BB_PLUS,
            'BB': RatingScale.BB,
            'BB-': RatingScale.BB_MINUS,
            'B+': RatingScale.B_PLUS,
            'B': RatingScale.B,
            'B-': RatingScale.B_MINUS,
            'CCC+': RatingScale.CCC_PLUS,
            'CCC': RatingScale.CCC,
            'CCC-': RatingScale.CCC_MINUS,
            'CC': RatingScale.CC,
            'C': RatingScale.C,
            'D': RatingScale.D,
            'NR': RatingScale.NR
        }
        
        self._moody_mapping = {
            'Aaa': RatingScale.AAA,
            'Aa1': RatingScale.AA_PLUS,
            'Aa2': RatingScale.AA,
            'Aa3': RatingScale.AA_MINUS,
            'A1': RatingScale.A_PLUS,
            'A2': RatingScale.A,
            'A3': RatingScale.A_MINUS,
            'Baa1': RatingScale.BBB_PLUS,
            'Baa2': RatingScale.BBB,
            'Baa3': RatingScale.BBB_MINUS,
            'Ba1': RatingScale.BB_PLUS,
            'Ba2': RatingScale.BB,
            'Ba3': RatingScale.BB_MINUS,
            'B1': RatingScale.B_PLUS,
            'B2': RatingScale.B,
            'B3': RatingScale.B_MINUS,
            'Caa1': RatingScale.CCC_PLUS,
            'Caa2': RatingScale.CCC,
            'Caa3': RatingScale.CCC_MINUS,
            'Ca': RatingScale.CC,
            'C': RatingScale.C,
            'D': RatingScale.D,
            'NR': RatingScale.NR
        }
        
        self._fitch_mapping = {
            'AAA': RatingScale.AAA,
            'AA+': RatingScale.AA_PLUS,
            'AA': RatingScale.AA,
            'AA-': RatingScale.AA_MINUS,
            'A+': RatingScale.A_PLUS,
            'A': RatingScale.A,
            'A-': RatingScale.A_MINUS,
            'BBB+': RatingScale.BBB_PLUS,
            'BBB': RatingScale.BBB,
            'BBB-': RatingScale.BBB_MINUS,
            'BB+': RatingScale.BB_PLUS,
            'BB': RatingScale.BB,
            'BB-': RatingScale.BB_MINUS,
            'B+': RatingScale.B_PLUS,
            'B': RatingScale.B,
            'B-': RatingScale.B_MINUS,
            'CCC+': RatingScale.CCC_PLUS,
            'CCC': RatingScale.CCC,
            'CCC-': RatingScale.CCC_MINUS,
            'CC': RatingScale.CC,
            'C': RatingScale.C,
            'D': RatingScale.D,
            'NR': RatingScale.NR
        }
        
        self._agency_mappings = {
            RatingAgency.SP: self._sp_mapping,
            RatingAgency.MOODY: self._moody_mapping,
            RatingAgency.FITCH: self._fitch_mapping
        }
    
    def normalize_rating(self, rating: str, agency: RatingAgency) -> RatingScale:
        """Convert agency rating to normalized scale"""
        if not rating or pd.isna(rating):
            return RatingScale.NR
            
        mapping = self._agency_mappings.get(agency, {})
        return mapping.get(rating, RatingScale.NR)
    
    def get_rating_hierarchy_value(self, rating_scale: RatingScale) -> int:
        """Get numerical value for rating comparison (lower is better)"""
        return rating_scale.value

# =============================================================================
# ABSTRACT BASE CLASS
# =============================================================================

class AbstractEnrichment(ABC):
    """Abstract base class for all enrichment operations"""
    
    def __init__(self, name: str):
        self.name = name
        self.enrichment_log = {}
        self._raw_dataframe = None
        self._enriched_dataframe = None
        self._reference_data = {}
        self._last_enrichment_timestamp = None
        
    @property
    def raw_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the raw input dataframe"""
        return self._raw_dataframe
    
    @property
    def enriched_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the enriched dataframe"""
        return self._enriched_dataframe
    
    @property
    def reference_data(self) -> Dict[str, Any]:
        """Get the loaded reference data"""
        return self._reference_data.copy()  # Return copy to prevent external modification
    
    @property
    def has_reference_data(self) -> bool:
        """Check if reference data is loaded"""
        return len(self._reference_data) > 0
    
    @property
    def enrichment_count(self) -> int:
        """Get count of successful enrichments"""
        success_count = 0
        for logs in self.enrichment_log.values():
            success_count += sum(1 for log in logs if log.get('status') == EnrichmentStatus.SUCCESS.value)
        return success_count
    
    @property
    def last_enrichment_timestamp(self) -> Optional[pd.Timestamp]:
        """Get timestamp of last enrichment operation"""
        return self._last_enrichment_timestamp
    
    def clear_data(self):
        """Clear all stored dataframes and reference data"""
        self._raw_dataframe = None
        self._enriched_dataframe = None
        self._reference_data.clear()
        self.enrichment_log.clear()
        self._last_enrichment_timestamp = None
        logger.info(f"Cleared all data for {self.name}")
    
    @abstractmethod
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        """
        Load reference data from database using the provided keys.
        
        Args:
            keys: List of identifiers (ISIN, Bond ID, etc.)
            
        Returns:
            Dictionary mapping keys to reference data
            
        Raises:
            ReferenceDataError: If reference data cannot be loaded
        """
        pass
    
    @abstractmethod
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Apply enrichment to the dataframe.
        
        Args:
            df: Input dataframe containing trade data
            
        Returns:
            Enriched dataframe with additional columns
            
        Raises:
            EnrichmentProcessingError: If enrichment processing fails
        """
        pass
    
    def _store_dataframes(self, raw_df: pd.DataFrame, enriched_df: pd.DataFrame):
        """Store raw and enriched dataframes"""
        self._raw_dataframe = raw_df.copy()
        self._enriched_dataframe = enriched_df.copy()
        self._last_enrichment_timestamp = pd.Timestamp.now()
    
    def _store_reference_data(self, ref_data: Dict[str, Any]):
        """Store reference data"""
        self._reference_data.update(ref_data)
        logger.info(f"Stored reference data for {len(ref_data)} keys in {self.name}")
        
    def _log_enrichment(self, key: str, status: EnrichmentStatus, message: str = ""):
        """Log enrichment operation per key"""
        if key not in self.enrichment_log:
            self.enrichment_log[key] = []
        
        self.enrichment_log[key].append({
            'enrichment': self.name,
            'status': status.value,
            'message': message,
            'timestamp': pd.Timestamp.now()
        })
        
        logger.info(f"Enrichment {self.name} - {key}: {status.value} - {message}")
        
    def get_enrichment_stats(self) -> Dict[str, int]:
        """Get statistics about enrichment operations"""
        stats = {
            'total_keys': len(self.enrichment_log),
            'successful': 0,
            'failed': 0,
            'partial': 0,
            'no_data': 0
        }
        
        for logs in self.enrichment_log.values():
            for log in logs:
                status = log.get('status')
                if status == EnrichmentStatus.SUCCESS.value:
                    stats['successful'] += 1
                elif status == EnrichmentStatus.FAILED.value:
                    stats['failed'] += 1
                elif status == EnrichmentStatus.PARTIAL.value:
                    stats['partial'] += 1
                elif status == EnrichmentStatus.NO_DATA.value:
                    stats['no_data'] += 1
        
        return stats


# =============================================================================
# ENRICHMENT FACTORY
# =============================================================================

class EnrichmentFactory:
    """Factory for auto-registering and creating enrichment classes"""
    
    _enrichments = {}
    
    @classmethod
    def register(cls, enrichment_class):
        """Decorator to auto-register enrichment classes"""
        if not issubclass(enrichment_class, AbstractEnrichment):
            raise EnrichmentConfigurationError(
                f"Class {enrichment_class.__name__} must inherit from AbstractEnrichment"
            )
        
        cls._enrichments[enrichment_class.__name__] = enrichment_class
        logger.info(f"Registered enrichment class: {enrichment_class.__name__}")
        return enrichment_class
    
    @classmethod
    def create_enrichment(cls, name: str) -> AbstractEnrichment:
        """Create enrichment instance by name"""
        if name not in cls._enrichments:
            available = ', '.join(cls._enrichments.keys())
            raise EnrichmentConfigurationError(
                f"Unknown enrichment: {name}. Available: {available}"
            )
        
        return cls._enrichments[name]()
    
    @classmethod
    def get_available_enrichments(cls) -> List[str]:
        """Get list of available enrichment names"""
        return list(cls._enrichments.keys())
    
    @classmethod
    def create_all_enrichments(cls) -> List[AbstractEnrichment]:
        """Create instances of all registered enrichments"""
        return [cls.create_enrichment(name) for name in cls._enrichments.keys()]


# Decorator function for easy registration
def register_enrichment(cls):
    """Decorator to register enrichment classes with the factory"""
    return EnrichmentFactory.register(cls)


# =============================================================================
# BOND RATING ENRICHMENT
# =============================================================================

@register_enrichment
class BondRatingEnrichment(AbstractEnrichment):
    """Enrichment class for bond credit ratings"""
    
    def __init__(self):
        super().__init__("BondRatingEnrichment")
        self.rating_mapper = RatingMapper()
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        """
        Load bond rating data from RefData database.
        
        Args:
            keys: List of ISINs or Bond IDs
            
        Returns:
            Dictionary with rating data per key
            
        Raises:
            ReferenceDataError: If rating data cannot be loaded
        """
        try:
            # Placeholder for actual database call
            # In real implementation, this would call your RefData wrapper functions
            logger.info(f"Loading rating data for {len(keys)} instruments")
            
            # Mock data structure that would come from your database
            rating_data = {}
            for key in keys:
                # This would be replaced with actual database call
                rating_data[key] = {
                    RatingAgency.SP.value: 'A+',
                    RatingAgency.MOODY.value: 'A1',
                    RatingAgency.FITCH.value: 'A+'
                }
            
            # Store the loaded reference data
            self._store_reference_data(rating_data)
            return rating_data
            
        except Exception as e:
            raise ReferenceDataError(f"Failed to load rating data: {str(e)}")
    
    def get_ratings_for_isins(self, isins: List[str], 
                             return_format: str = 'dataframe') -> Union[pd.DataFrame, Dict]:
        """
        Get comprehensive rating information for list of ISINs.
        
        Args:
            isins: List of ISIN identifiers
            return_format: 'dataframe' or 'dictionary'
            
        Returns:
            Rating information in requested format
            
        Raises:
            EnrichmentDataError: If ISIN list is invalid
            RatingCalculationError: If rating calculations fail
        """
        if not isins:
            raise EnrichmentDataError("ISIN list cannot be empty")
        
        try:
            rating_data = self.load_reference_data(isins)
            results = {}
            
            for isin in isins:
                if isin not in rating_data:
                    self._log_enrichment(isin, EnrichmentStatus.NO_DATA, "No rating data found")
                    continue
                    
                ratings = rating_data[isin]
                rating_summary = self._calculate_rating_summary(ratings)
                
                results[isin] = {
                    'isin': isin,
                    'sp_rating': ratings.get(RatingAgency.SP.value),
                    'moody_rating': ratings.get(RatingAgency.MOODY.value),
                    'fitch_rating': ratings.get(RatingAgency.FITCH.value),
                    'average_rating': rating_summary.average_rating.name if rating_summary.average_rating else None,
                    'best_rating': rating_summary.best_rating.name if rating_summary.best_rating else None,
                    'worst_rating': rating_summary.worst_rating.name if rating_summary.worst_rating else None,
                    'best_agency': rating_summary.best_agency.value if rating_summary.best_agency else None,
                    'worst_agency': rating_summary.worst_agency.value if rating_summary.worst_agency else None,
                    'rating_count': rating_summary.rating_count
                }
                
                self._log_enrichment(isin, EnrichmentStatus.SUCCESS, f"Processed {rating_summary.rating_count} ratings")
            
            if return_format.lower() == 'dataframe':
                return pd.DataFrame.from_dict(results, orient='index').reset_index(drop=True)
            else:
                return results
                
        except Exception as e:
            if isinstance(e, (EnrichmentDataError, ReferenceDataError)):
                raise
            raise RatingCalculationError(f"Failed to calculate ratings: {str(e)}")
    
    def _calculate_rating_summary(self, ratings: Dict[str, str]) -> RatingSummary:
        """Calculate rating statistics from agency ratings"""
        try:
            valid_ratings = []
            
            for agency_name, rating_str in ratings.items():
                if not rating_str or pd.isna(rating_str) or rating_str == 'NR':
                    continue
                    
                # Find matching agency enum
                agency = None
                for ag in RatingAgency:
                    if ag.value == agency_name:
                        agency = ag
                        break
                
                if agency:
                    normalized_rating = self.rating_mapper.normalize_rating(rating_str, agency)
                    if normalized_rating != RatingScale.NR:
                        valid_ratings.append(RatingInfo(
                            rating=normalized_rating,
                            agency=agency,
                            scale_value=self.rating_mapper.get_rating_hierarchy_value(normalized_rating)
                        ))
            
            if not valid_ratings:
                return RatingSummary(None, None, None, None, None, 0)
            
            # Calculate statistics
            scale_values = [r.scale_value for r in valid_ratings]
            avg_value = np.mean(scale_values)
            
            # Find closest rating to average
            avg_rating = min(valid_ratings, key=lambda x: abs(x.scale_value - avg_value)).rating
            
            # Best rating (lowest numerical value)
            best_rating_info = min(valid_ratings, key=lambda x: x.scale_value)
            
            # Worst rating (highest numerical value)
            worst_rating_info = max(valid_ratings, key=lambda x: x.scale_value)
            
            return RatingSummary(
                average_rating=avg_rating,
                best_rating=best_rating_info.rating,
                worst_rating=worst_rating_info.rating,
                best_agency=best_rating_info.agency,
                worst_agency=worst_rating_info.agency,
                rating_count=len(valid_ratings)
            )
            
        except Exception as e:
            raise RatingCalculationError(f"Failed to calculate rating summary: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        """Apply rating enrichment to trade dataframe"""
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
                
            if 'ISIN' not in df.columns:
                raise EnrichmentDataError("ISIN column not found in dataframe")
            
            # Store raw dataframe
            raw_df = df.copy()
            
            isins = df['ISIN'].dropna().unique().tolist()
            if not isins:
                logger.warning("No valid ISINs found in dataframe")
                self._store_dataframes(raw_df, df)
                return df
            
            rating_df = self.get_ratings_for_isins(isins, return_format='dataframe')
            
            # Merge with original dataframe
            enriched_df = df.merge(rating_df, left_on='ISIN', right_on='isin', how='left')
            
            # Store both dataframes
            self._store_dataframes(raw_df, enriched_df)
            
            return enriched_df
            
        except Exception as e:
            if isinstance(e, (EnrichmentDataError, RatingCalculationError, ReferenceDataError)):
                raise
            raise EnrichmentProcessingError(f"Failed to apply rating enrichment: {str(e)}")

# =============================================================================
# OTHER ENRICHMENT CLASSES (STUBS)
# =============================================================================

@register_enrichment
class AssetClassificationEnrichment(AbstractEnrichment):
    """Enrichment for asset classification data"""
    
    def __init__(self):
        super().__init__("AssetClassificationEnrichment")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading asset classification data for {len(keys)} instruments")
            # Implementation would go here
            classification_data = {}
            self._store_reference_data(classification_data)
            return classification_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load asset classification data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            # Implementation would go here
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply asset classification enrichment: {str(e)}")


@register_enrichment
class CounterpartyEnrichment(AbstractEnrichment):
    """Enrichment for counterparty data"""
    
    def __init__(self):
        super().__init__("CounterpartyEnrichment")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading counterparty data for {len(keys)} instruments")
            # Implementation would go here
            counterparty_data = {}
            self._store_reference_data(counterparty_data)
            return counterparty_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load counterparty data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            # Implementation would go here
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply counterparty enrichment: {str(e)}")


@register_enrichment
class BondLiquidityAndHaircuts(AbstractEnrichment):
    """Enrichment for bond liquidity and haircut data"""
    
    def __init__(self):
        super().__init__("BondLiquidityAndHaircuts")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading liquidity and haircut data for {len(keys)} instruments")
            # Implementation would go here
            liquidity_data = {}
            self._store_reference_data(liquidity_data)
            return liquidity_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load liquidity and haircut data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            # Implementation would go here
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply liquidity and haircuts enrichment: {str(e)}")
        return df


# =============================================================================
# ENRICHMENT APPLIER
# =============================================================================

class EnrichmentApplier:
    """Main class to apply all enrichments to trade data"""
    
    def __init__(self, enrichment_names: Optional[List[str]] = None):
        """
        Initialize with specific enrichments or all available ones.
        
        Args:
            enrichment_names: List of specific enrichment names to use,
                            None to use all available enrichments
        """
        try:
            if enrichment_names is None:
                self.enrichments = EnrichmentFactory.create_all_enrichments()
            else:
                self.enrichments = [
                    EnrichmentFactory.create_enrichment(name) 
                    for name in enrichment_names
                ]
            
            self.enrichment_log = {}
            self._raw_dataframe = None
            self._enriched_dataframe = None
            self._enrichment_history = []
            
        except Exception as e:
            raise EnrichmentConfigurationError(f"Failed to initialize EnrichmentApplier: {str(e)}")
    
    @property
    def raw_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the original raw dataframe"""
        return self._raw_dataframe
    
    @property
    def enriched_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the final enriched dataframe"""
        return self._enriched_dataframe
    
    @property
    def enrichment_history(self) -> List[Dict[str, Any]]:
        """Get history of enrichment operations"""
        return self._enrichment_history.copy()
    
    @property
    def enrichment_names(self) -> List[str]:
        """Get list of enrichment names being applied"""
        return [enrichment.name for enrichment in self.enrichments]
    
    @property
    def total_enrichments_applied(self) -> int:
        """Get total count of successful enrichments across all classes"""
        return sum(enrichment.enrichment_count for enrichment in self.enrichments)
    
    def get_enrichment_by_name(self, name: str) -> Optional[AbstractEnrichment]:
        """Get enrichment instance by name"""
        for enrichment in self.enrichments:
            if enrichment.name == name:
                return enrichment
        return None
    
    def clear_all_data(self):
        """Clear all stored data from applier and enrichments"""
        self._raw_dataframe = None
        self._enriched_dataframe = None
        self.enrichment_log.clear()
        self._enrichment_history.clear()
        
        for enrichment in self.enrichments:
            enrichment.clear_data()
        
        logger.info("Cleared all data from EnrichmentApplier and all enrichments")
    
    def apply_all_enrichments(self, df: pd.DataFrame) -> Dict[str, pd.DataFrame]:
        """
        Apply all enrichments to the input dataframe.
        
        Args:
            df: Input trade dataframe with Bond ID and ISIN columns
            
        Returns:
            Dictionary with 'raw' and 'enriched' dataframes
            
        Raises:
            EnrichmentDataError: If input dataframe is invalid
            EnrichmentProcessingError: If enrichment processing fails
        """
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            logger.info("Starting enrichment process")
            
            # Store raw data
            self._raw_dataframe = df.copy()
            current_df = df.copy()
            
            # Start with raw data
            result = {
                'raw': df.copy(),
                'enriched': df.copy()
            }
            
            successful_enrichments = []
            failed_enrichments = []
            
            # Apply each enrichment
            for enrichment in self.enrichments:
                logger.info(f"Applying {enrichment.name}")
                
                try:
                    enrichment_start_time = pd.Timestamp.now()
                    result['enriched'] = enrichment.apply_enrichment(result['enriched'])
                    enrichment_end_time = pd.Timestamp.now()
                    
                    # Record successful enrichment
                    self._enrichment_history.append({
                        'enrichment_name': enrichment.name,
                        'status': 'SUCCESS',
                        'start_time': enrichment_start_time,
                        'end_time': enrichment_end_time,
                        'duration': enrichment_end_time - enrichment_start_time,
                        'rows_processed': len(result['enriched']),
                        'enrichment_count': enrichment.enrichment_count
                    })
                    
                    successful_enrichments.append(enrichment.name)
                    
                    # Consolidate logs
                    for key, logs in enrichment.enrichment_log.items():
                        if key not in self.enrichment_log:
                            self.enrichment_log[key] = []
                        self.enrichment_log[key].extend(logs)
                        
                    logger.info(f"Successfully applied {enrichment.name}")
                    
                except Exception as e:
                    error_msg = f"Failed to apply {enrichment.name}: {str(e)}"
                    logger.error(error_msg)
                    
                    # Record failed enrichment
                    self._enrichment_history.append({
                        'enrichment_name': enrichment.name,
                        'status': 'FAILED',
                        'error_message': str(e),
                        'start_time': pd.Timestamp.now(),
                        'end_time': pd.Timestamp.now()
                    })
                    
                    failed_enrichments.append(enrichment.name)
                    continue
            
            # Store final enriched dataframe
            self._enriched_dataframe = result['enriched'].copy()
            
            logger.info(f"Enrichment process completed. "
                       f"Successful: {len(successful_enrichments)}, "
                       f"Failed: {len(failed_enrichments)}")
            
            if failed_enrichments:
                logger.warning(f"Failed enrichments: {', '.join(failed_enrichments)}")
            
            return result
            
        except Exception as e:
            if isinstance(e, (EnrichmentDataError, EnrichmentProcessingError)):
                raise
            raise EnrichmentProcessingError(f"Failed to apply enrichments: {str(e)}")
    
    def get_enrichment_summary(self) -> pd.DataFrame:
        """Get summary of all enrichments applied per ISIN"""
        summary_data = []
        
        for isin, logs in self.enrichment_log.items():
            for log_entry in logs:
                summary_data.append({
                    'ISIN': isin,
                    'Enrichment': log_entry['enrichment'],
                    'Status': log_entry['status'],
                    'Message': log_entry['message'],
                    'Timestamp': log_entry['timestamp']
                })
        
        return pd.DataFrame(summary_data)
    
    def get_enrichment_performance_summary(self) -> pd.DataFrame:
        """Get performance summary of enrichment operations"""
        return pd.DataFrame(self._enrichment_history)
    
    def get_overall_stats(self) -> Dict[str, Any]:
        """Get overall statistics about the enrichment process"""
        if not self._enrichment_history:
            return {}
        
        successful = [h for h in self._enrichment_history if h['status'] == 'SUCCESS']
        failed = [h for h in self._enrichment_history if h['status'] == 'FAILED']
        
        total_duration = sum([h.get('duration', pd.Timedelta(0)) for h in successful], pd.Timedelta(0))
        
        return {
            'total_enrichments_attempted': len(self._enrichment_history),
            'successful_enrichments': len(successful),
            'failed_enrichments': len(failed),
            'success_rate': len(successful) / len(self._enrichment_history) if self._enrichment_history else 0,
            'total_processing_time': total_duration,
            'average_processing_time': total_duration / len(successful) if successful else pd.Timedelta(0),
            'total_records_processed': len(self._enriched_dataframe) if self._enriched_dataframe is not None else 0,
            'total_enrichment_operations': self.total_enrichments_applied
        }

# =============================================================================
# USAGE EXAMPLE
# =============================================================================

def example_usage():
    """Example of how to use the enhanced enrichment framework"""
    
    try:
        # Sample trade data
        trade_data = pd.DataFrame({
            'TradeID': ['T001', 'T002', 'T003'],
            'ISIN': ['US123456789', 'GB987654321', 'DE555666777'],
            'BondID': ['B001', 'B002', 'B003'],
            'Quantity': [1000000, 2000000, 1500000],
            'Price': [99.5, 101.2, 98.8]
        })
        
        print("=== Enhanced Trade Data Enrichment Framework Example ===\n")
        
        # Create enrichment applier
        applier = EnrichmentApplier()
        
        print(f"Available enrichments: {applier.enrichment_names}")
        print(f"Total enrichment classes: {len(applier.enrichments)}\n")
        
        # Apply all enrichments
        results = applier.apply_all_enrichments(trade_data)
        
        print("Raw Data:")
        print(results['raw'])
        print("\nEnriched Data:")
        print(results['enriched'])
        
        # Access stored dataframes via properties
        print(f"\nRaw dataframe shape: {applier.raw_dataframe.shape}")
        print(f"Enriched dataframe shape: {applier.enriched_dataframe.shape}")
        
        print(f"\nTotal enrichments applied: {applier.total_enrichments_applied}")
        
        print("\nEnrichment Summary:")
        summary = applier.get_enrichment_summary()
        if not summary.empty:
            print(summary)
        else:
            print("No enrichment operations logged")
        
        print("\nPerformance Summary:")
        perf_summary = applier.get_enrichment_performance_summary()
        print(perf_summary)
        
        print("\nOverall Statistics:")
        stats = applier.get_overall_stats()
        for key, value in stats.items():
            print(f"  {key}: {value}")
        
        # Example of using specific rating functionality
        print("\n=== Rating Enrichment Specific Example ===")
        rating_enrichment = applier.get_enrichment_by_name("BondRatingEnrichment")
        
        if rating_enrichment:
            isins = ['US123456789', 'GB987654321']
            try:
                ratings_df = rating_enrichment.get_ratings_for_isins(isins)
                print("\nRating Analysis:")
                print(ratings_df)
                
                print(f"\nRating enrichment stats:")
                print(rating_enrichment.get_enrichment_stats())
                
                print(f"Has reference data: {rating_enrichment.has_reference_data}")
                print(f"Reference data keys: {list(rating_enrichment.reference_data.keys())}")
                
            except Exception as e:
                print(f"Rating enrichment failed: {str(e)}")
        
        # Example of error handling
        print("\n=== Error Handling Example ===")
        try:
            # Try to apply enrichment to empty dataframe
            empty_df = pd.DataFrame()
            applier.apply_all_enrichments(empty_df)
        except EnrichmentDataError as e:
            print(f"Caught expected error: {e}")
        
        # Example of factory usage with decorators
        print("\n=== Factory Registration Example ===")
        print(f"Available enrichments: {EnrichmentFactory.get_available_enrichments()}")
        
        # Create specific enrichment
        try:
            bond_rating = EnrichmentFactory.create_enrichment("BondRatingEnrichment")
            print(f"Created enrichment: {bond_rating.name}")
        except EnrichmentConfigurationError as e:
            print(f"Factory error: {e}")
            
    except Exception as e:
        print(f"Example failed with error: {str(e)}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    example_usage()
