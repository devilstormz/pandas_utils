[⚠️ Suspicious Content] """
Trade Data Enrichment Framework

A comprehensive framework for enriching trade datasets with reference data.
Supports multiple enrichment types with factory pattern and automatic registration.
"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Optional, Union, Tuple, Any
from collections import namedtuple
import pandas as pd
import numpy as np
import logging
from functools import wraps

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# =============================================================================
# CUSTOM EXCEPTIONS
# =============================================================================

class EnrichmentError(Exception):
    """Base exception for enrichment operations"""
    pass


class EnrichmentDataError(EnrichmentError):
    """Exception raised when enrichment data is invalid or missing"""
    pass


class EnrichmentProcessingError(EnrichmentError):
    """Exception raised during enrichment processing"""
    pass


class EnrichmentConfigurationError(EnrichmentError):
    """Exception raised for configuration issues"""
    pass


class ReferenceDataError(EnrichmentError):
    """Exception raised when reference data cannot be loaded"""
    pass


class RatingCalculationError(EnrichmentError):
    """Exception raised during rating calculations"""
    pass


# =============================================================================
# ENUMS AND NAMEDTUPLES
# =============================================================================

class RatingScale(Enum):
    """Normalized rating scale for all agencies"""
    AAA = 1
    AA_PLUS = 2
    AA = 3
    AA_MINUS = 4
    A_PLUS = 5
    A = 6
    A_MINUS = 7
    BBB_PLUS = 8
    BBB = 9
    BBB_MINUS = 10
    BB_PLUS = 11
    BB = 12
    BB_MINUS = 13
    B_PLUS = 14
    B = 15
    B_MINUS = 16
    CCC_PLUS = 17
    CCC = 18
    CCC_MINUS = 19
    CC = 20
    C = 21
    D = 22
    NR = 999  # Not Rated


class RatingAgency(Enum):
    """Rating agencies enumeration"""
    SP = "S&P"
    MOODY = "Moody's"
    FITCH = "Fitch"


class EnrichmentStatus(Enum):
    """Status of enrichment operation"""
    SUCCESS = "SUCCESS"
    PARTIAL = "PARTIAL"
    FAILED = "FAILED"
    NO_DATA = "NO_DATA"


# Named tuples for structured data
EnrichmentResult = namedtuple('EnrichmentResult', ['status', 'message', 'data'])
RatingInfo = namedtuple('RatingInfo', ['rating', 'agency', 'scale_value'])
RatingSummary = namedtuple('RatingSummary', [
    'average_rating', 'best_rating', 'worst_rating', 
    'best_agency', 'worst_agency', 'rating_count'
])

# =============================================================================
# RATING MAPPERS
# =============================================================================

class RatingMapper:
    """Maps agency-specific ratings to normalized scale"""
    
    def __init__(self):
        self._sp_mapping = {
            'AAA': RatingScale.AAA,
            'AA+': RatingScale.AA_PLUS,
            'AA': RatingScale.AA,
            'AA-': RatingScale.AA_MINUS,
            'A+': RatingScale.A_PLUS,
            'A': RatingScale.A,
            'A-': RatingScale.A_MINUS,
            'BBB+': RatingScale.BBB_PLUS,
            'BBB': RatingScale.BBB,
            'BBB-': RatingScale.BBB_MINUS,
            'BB+': RatingScale.BB_PLUS,
            'BB': RatingScale.BB,
            'BB-': RatingScale.BB_MINUS,
            'B+': RatingScale.B_PLUS,
            'B': RatingScale.B,
            'B-': RatingScale.B_MINUS,
            'CCC+': RatingScale.CCC_PLUS,
            'CCC': RatingScale.CCC,
            'CCC-': RatingScale.CCC_MINUS,
            'CC': RatingScale.CC,
            'C': RatingScale.C,
            'D': RatingScale.D,
            'NR': RatingScale.NR
        }
        
        self._moody_mapping = {
            'Aaa': RatingScale.AAA,
            'Aa1': RatingScale.AA_PLUS,
            'Aa2': RatingScale.AA,
            'Aa3': RatingScale.AA_MINUS,
            'A1': RatingScale.A_PLUS,
            'A2': RatingScale.A,
            'A3': RatingScale.A_MINUS,
            'Baa1': RatingScale.BBB_PLUS,
            'Baa2': RatingScale.BBB,
            'Baa3': RatingScale.BBB_MINUS,
            'Ba1': RatingScale.BB_PLUS,
            'Ba2': RatingScale.BB,
            'Ba3': RatingScale.BB_MINUS,
            'B1': RatingScale.B_PLUS,
            'B2': RatingScale.B,
            'B3': RatingScale.B_MINUS,
            'Caa1': RatingScale.CCC_PLUS,
            'Caa2': RatingScale.CCC,
            'Caa3': RatingScale.CCC_MINUS,
            'Ca': RatingScale.CC,
            'C': RatingScale.C,
            'D': RatingScale.D,
            'NR': RatingScale.NR
        }
        
        self._fitch_mapping = {
            'AAA': RatingScale.AAA,
            'AA+': RatingScale.AA_PLUS,
            'AA': RatingScale.AA,
            'AA-': RatingScale.AA_MINUS,
            'A+': RatingScale.A_PLUS,
            'A': RatingScale.A,
            'A-': RatingScale.A_MINUS,
            'BBB+': RatingScale.BBB_PLUS,
            'BBB': RatingScale.BBB,
            'BBB-': RatingScale.BBB_MINUS,
            'BB+': RatingScale.BB_PLUS,
            'BB': RatingScale.BB,
            'BB-': RatingScale.BB_MINUS,
            'B+': RatingScale.B_PLUS,
            'B': RatingScale.B,
            'B-': RatingScale.B_MINUS,
            'CCC+': RatingScale.CCC_PLUS,
            'CCC': RatingScale.CCC,
            'CCC-': RatingScale.CCC_MINUS,
            'CC': RatingScale.CC,
            'C': RatingScale.C,
            'D': RatingScale.D,
            'NR': RatingScale.NR
        }
        
        self._agency_mappings = {
            RatingAgency.SP: self._sp_mapping,
            RatingAgency.MOODY: self._moody_mapping,
            RatingAgency.FITCH: self._fitch_mapping
        }
    
    def normalize_rating(self, rating: str, agency: RatingAgency) -> RatingScale:
        """Convert agency rating to normalized scale"""
        if not rating or pd.isna(rating):
            return RatingScale.NR
            
        mapping = self._agency_mappings.get(agency, {})
        return mapping.get(rating, RatingScale.NR)
    
    def get_rating_hierarchy_value(self, rating_scale: RatingScale) -> int:
        """Get numerical value for rating comparison (lower is better)"""
        return rating_scale.value

# =============================================================================
# ABSTRACT BASE CLASS
# =============================================================================

class AbstractEnrichment(ABC):
    """Abstract base class for all enrichment operations"""
    
    def __init__(self, name: str):
        self.name = name
        self.enrichment_log = {}
        self._raw_dataframe = None
        self._enriched_dataframe = None
        self._reference_data = {}
        self._last_enrichment_timestamp = None
        
    @property
    def raw_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the raw input dataframe"""
        return self._raw_dataframe
    
    @property
    def enriched_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the enriched dataframe"""
        return self._enriched_dataframe
    
    @property
    def reference_data(self) -> Dict[str, Any]:
        """Get the loaded reference data"""
        return self._reference_data.copy()  # Return copy to prevent external modification
    
    @property
    def has_reference_data(self) -> bool:
        """Check if reference data is loaded"""
        return len(self._reference_data) > 0
    
    @property
    def enrichment_count(self) -> int:
        """Get count of successful enrichments"""
        success_count = 0
        for logs in self.enrichment_log.values():
            success_count += sum(1 for log in logs if log.get('status') == EnrichmentStatus.SUCCESS.value)
        return success_count
    
    @property
    def last_enrichment_timestamp(self) -> Optional[pd.Timestamp]:
        """Get timestamp of last enrichment operation"""
        return self._last_enrichment_timestamp
    
    def clear_data(self):
        """Clear all stored dataframes and reference data"""
        self._raw_dataframe = None
        self._enriched_dataframe = None
        self._reference_data.clear()
        self.enrichment_log.clear()
        self._last_enrichment_timestamp = None
        logger.info(f"Cleared all data for {self.name}")
    
    @abstractmethod
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        """
        Load reference data from database using the provided keys.
        
        Args:
            keys: List of identifiers (ISIN, Bond ID, etc.)
            
        Returns:
            Dictionary mapping keys to reference data
            
        Raises:
            ReferenceDataError: If reference data cannot be loaded
        """
        pass
    
    @abstractmethod
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Apply enrichment to the dataframe.
        
        Args:
            df: Input dataframe containing trade data
            
        Returns:
            Enriched dataframe with additional columns
            
        Raises:
            EnrichmentProcessingError: If enrichment processing fails
        """
        pass
    
    def _store_dataframes(self, raw_df: pd.DataFrame, enriched_df: pd.DataFrame):
        """Store raw and enriched dataframes"""
        self._raw_dataframe = raw_df.copy()
        self._enriched_dataframe = enriched_df.copy()
        self._last_enrichment_timestamp = pd.Timestamp.now()
    
    def _store_reference_data(self, ref_data: Dict[str, Any]):
        """Store reference data"""
        self._reference_data.update(ref_data)
        logger.info(f"Stored reference data for {len(ref_data)} keys in {self.name}")
        
    def _log_enrichment(self, key: str, status: EnrichmentStatus, message: str = ""):
        """Log enrichment operation per key"""
        if key not in self.enrichment_log:
            self.enrichment_log[key] = []
        
        self.enrichment_log[key].append({
            'enrichment': self.name,
            'status': status.value,
            'message': message,
            'timestamp': pd.Timestamp.now()
        })
        
        logger.info(f"Enrichment {self.name} - {key}: {status.value} - {message}")
        
    def get_enrichment_stats(self) -> Dict[str, int]:
        """Get statistics about enrichment operations"""
        stats = {
            'total_keys': len(self.enrichment_log),
            'successful': 0,
            'failed': 0,
            'partial': 0,
            'no_data': 0
        }
        
        for logs in self.enrichment_log.values():
            for log in logs:
                status = log.get('status')
                if status == EnrichmentStatus.SUCCESS.value:
                    stats['successful'] += 1
                elif status == EnrichmentStatus.FAILED.value:
                    stats['failed'] += 1
                elif status == EnrichmentStatus.PARTIAL.value:
                    stats['partial'] += 1
                elif status == EnrichmentStatus.NO_DATA.value:
                    stats['no_data'] += 1
        
        return stats

# Enhanced decorator function for easy registration with metadata
def register_enrichment(tags: Optional[List[str]] = None,
                       dependencies: Optional[List[str]] = None,
                       description: str = "",
                       performance_impact: str = "medium"):
    """
    Decorator to register enrichment classes with metadata
    
    Args:
        tags: List of tags for categorization
        dependencies: List of enrichment names this depends on
        description: Human-readable description
        performance_impact: 'low', 'medium', 'high'
    
    Usage:
        @register_enrichment(tags=['rating', 'credit'], performance_impact='low')
        class MyEnrichment(AbstractEnrichment):
            pass
    """
    def decorator(cls):
        return EnrichmentFactory.register(
            cls, 
            tags=tags, 
            dependencies=dependencies,
            description=description,
            performance_impact=performance_impact
        )
    return decorator


# =============================================================================
# ENRICHMENT FACTORY
# =============================================================================

class EnrichmentFactory:
    """Factory for auto-registering and creating enrichment classes"""
    
    _enrichments = {}
    _enrichment_metadata = {}
    
    @classmethod
    def register(cls, enrichment_class, 
                 tags: Optional[List[str]] = None,
                 dependencies: Optional[List[str]] = None,
                 description: str = "",
                 performance_impact: str = "medium"):
        """
        Decorator to auto-register enrichment classes with metadata
        
        Args:
            enrichment_class: The enrichment class to register
            tags: List of tags for categorization (e.g., ['rating', 'credit', 'bond'])
            dependencies: List of enrichment names this depends on
            description: Human-readable description
            performance_impact: 'low', 'medium', 'high' - indicates processing cost
        """
        if not issubclass(enrichment_class, AbstractEnrichment):
            raise EnrichmentConfigurationError(
                f"Class {enrichment_class.__name__} must inherit from AbstractEnrichment"
            )
        
        class_name = enrichment_class.__name__
        cls._enrichments[class_name] = enrichment_class
        cls._enrichment_metadata[class_name] = {
            'tags': tags or [],
            'dependencies': dependencies or [],
            'description': description,
            'performance_impact': performance_impact,
            'class': enrichment_class
        }
        
        logger.info(f"Registered enrichment class: {class_name} with tags: {tags}")
        return enrichment_class
    
    @classmethod
    def create_enrichment(cls, name: str) -> AbstractEnrichment:
        """Create enrichment instance by name"""
        if name not in cls._enrichments:
            available = ', '.join(cls._enrichments.keys())
            raise EnrichmentConfigurationError(
                f"Unknown enrichment: {name}. Available: {available}"
            )
        
        return cls._enrichments[name]()
    
    @classmethod
    def get_available_enrichments(cls) -> List[str]:
        """Get list of available enrichment names"""
        return list(cls._enrichments.keys())
    
    @classmethod
    def get_enrichments_by_tags(cls, tags: List[str], 
                               match_any: bool = True) -> List[str]:
        """
        Get enrichment names by tags
        
        Args:
            tags: List of tags to search for
            match_any: If True, return enrichments with ANY tag; if False, ALL tags
            
        Returns:
            List of enrichment names matching the tag criteria
        """
        matching_enrichments = []
        
        for name, metadata in cls._enrichment_metadata.items():
            enrichment_tags = set(metadata['tags'])
            search_tags = set(tags)
            
            if match_any:
                if enrichment_tags.intersection(search_tags):
                    matching_enrichments.append(name)
            else:
                if search_tags.issubset(enrichment_tags):
                    matching_enrichments.append(name)
        
        return matching_enrichments
    
    @classmethod
    def get_enrichment_metadata(cls, name: str) -> Dict[str, Any]:
        """Get metadata for specific enrichment"""
        return cls._enrichment_metadata.get(name, {})
    
    @classmethod
    def get_all_metadata(cls) -> Dict[str, Dict[str, Any]]:
        """Get metadata for all enrichments"""
        return cls._enrichment_metadata.copy()
    
    @classmethod
    def resolve_dependencies(cls, enrichment_names: List[str]) -> List[str]:
        """
        Resolve dependencies and return ordered list of enrichments
        
        Args:
            enrichment_names: List of requested enrichment names
            
        Returns:
            Ordered list including dependencies
        """
        resolved = []
        visited = set()
        
        def resolve_recursive(name: str):
            if name in visited:
                return
            
            visited.add(name)
            metadata = cls._enrichment_metadata.get(name, {})
            dependencies = metadata.get('dependencies', [])
            
            # Resolve dependencies first
            for dep in dependencies:
                if dep not in cls._enrichments:
                    logger.warning(f"Dependency {dep} for {name} not found")
                    continue
                resolve_recursive(dep)
            
            if name not in resolved:
                resolved.append(name)
        
        for name in enrichment_names:
            resolve_recursive(name)
        
        return resolved
    
    @classmethod
    def create_enrichments_for_report(cls, report_config: Dict[str, Any]) -> List[AbstractEnrichment]:
        """
        Create enrichments based on report configuration
        
        Args:
            report_config: Dictionary containing report requirements
                {
                    'required_enrichments': ['BondRatingEnrichment'],
                    'optional_enrichments': ['CounterpartyEnrichment'],
                    'tags': ['rating', 'liquidity'],
                    'exclude_tags': ['high_cost'],
                    'performance_budget': 'medium'  # 'low', 'medium', 'high'
                }
        """
        selected_enrichments = []
        
        # Add required enrichments
        required = report_config.get('required_enrichments', [])
        selected_enrichments.extend(required)
        
        # Add optional enrichments if specified
        optional = report_config.get('optional_enrichments', [])
        selected_enrichments.extend(optional)
        
        # Add enrichments by tags
        include_tags = report_config.get('tags', [])
        if include_tags:
            tag_enrichments = cls.get_enrichments_by_tags(include_tags, match_any=True)
            selected_enrichments.extend(tag_enrichments)
        
        # Remove duplicates while preserving order
        unique_enrichments = []
        seen = set()
        for name in selected_enrichments:
            if name not in seen:
                unique_enrichments.append(name)
                seen.add(name)
        
        # Filter by exclude tags
        exclude_tags = report_config.get('exclude_tags', [])
        if exclude_tags:
            filtered_enrichments = []
            for name in unique_enrichments:
                metadata = cls._enrichment_metadata.get(name, {})
                enrichment_tags = set(metadata.get('tags', []))
                exclude_set = set(exclude_tags)
                
                if not enrichment_tags.intersection(exclude_set):
                    filtered_enrichments.append(name)
            unique_enrichments = filtered_enrichments
        
        # Filter by performance budget
        performance_budget = report_config.get('performance_budget')
        if performance_budget:
            performance_order = {'low': 1, 'medium': 2, 'high': 3}
            budget_level = performance_order.get(performance_budget, 3)
            
            performance_filtered = []
            for name in unique_enrichments:
                metadata = cls._enrichment_metadata.get(name, {})
                impact = metadata.get('performance_impact', 'medium')
                impact_level = performance_order.get(impact, 2)
                
                if impact_level <= budget_level:
                    performance_filtered.append(name)
                else:
                    logger.info(f"Excluding {name} due to performance budget ({impact} > {performance_budget})")
            
            unique_enrichments = performance_filtered
        
        # Resolve dependencies
        resolved_enrichments = cls.resolve_dependencies(unique_enrichments)
        
        # Create instances
        instances = []
        for name in resolved_enrichments:
            try:
                instances.append(cls.create_enrichment(name))
                logger.info(f"Created enrichment for report: {name}")
            except Exception as e:
                logger.error(f"Failed to create enrichment {name}: {str(e)}")
        
        return instances
    
    @classmethod
    def create_all_enrichments(cls) -> List[AbstractEnrichment]:
        """Create instances of all registered enrichments"""
        return [cls.create_enrichment(name) for name in cls._enrichments.keys()]




        
# =============================================================================
# ENRICHMENT APPLIER
# =============================================================================

class EnrichmentApplier:
    """Main class to apply all enrichments to trade data"""
    
    def __init__(self, enrichment_names: Optional[List[str]] = None, 
                 report_config: Optional[Dict[str, Any]] = None):
        """
        Initialize with specific enrichments, report config, or all available ones.
        
        Args:
            enrichment_names: List of specific enrichment names to use
            report_config: Dictionary containing report requirements for automatic selection
                          Takes precedence over enrichment_names if both provided
        """
        try:
            if report_config is not None:
                # Use report configuration to select enrichments
                self.enrichments = EnrichmentFactory.create_enrichments_for_report(report_config)
                self.report_config = report_config
                logger.info(f"Initialized with report config: {len(self.enrichments)} enrichments selected")
                
            elif enrichment_names is not None:
                # Use specific enrichment names with dependency resolution
                resolved_names = EnrichmentFactory.resolve_dependencies(enrichment_names)
                self.enrichments = [
                    EnrichmentFactory.create_enrichment(name) 
                    for name in resolved_names
                ]
                self.report_config = None
                logger.info(f"Initialized with specific enrichments (with dependencies): {resolved_names}")
                
            else:
                # Use all available enrichments
                self.enrichments = EnrichmentFactory.create_all_enrichments()
                self.report_config = None
                logger.info(f"Initialized with all available enrichments: {len(self.enrichments)}")
            
            self.enrichment_log = {}
            self._raw_dataframe = None
            self._enriched_dataframe = None
            self._enrichment_history = []
            
        except Exception as e:
            raise EnrichmentConfigurationError(f"Failed to initialize EnrichmentApplier: {str(e)}")
    
    @property
    def raw_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the original raw dataframe"""
        return self._raw_dataframe
    
    @property
    def enriched_dataframe(self) -> Optional[pd.DataFrame]:
        """Get the final enriched dataframe"""
        return self._enriched_dataframe
    
    @property
    def enrichment_history(self) -> List[Dict[str, Any]]:
        """Get history of enrichment operations"""
        return self._enrichment_history.copy()
    
    @property
    def enrichment_names(self) -> List[str]:
        """Get list of enrichment names being applied"""
        return [enrichment.name for enrichment in self.enrichments]
    
    @property
    def total_enrichments_applied(self) -> int:
        """Get total count of successful enrichments across all classes"""
        return sum(enrichment.enrichment_count for enrichment in self.enrichments)
    
    def get_enrichment_by_name(self, name: str) -> Optional[AbstractEnrichment]:
        """Get enrichment instance by name"""
        for enrichment in self.enrichments:
            if enrichment.name == name:
                return enrichment
        return None
    
    def get_enrichment_metadata_summary(self) -> pd.DataFrame:
        """Get summary of enrichment metadata for current selection"""
        metadata_list = []
        for enrichment in self.enrichments:
            metadata = EnrichmentFactory.get_enrichment_metadata(enrichment.name)
            metadata_list.append({
                'enrichment_name': enrichment.name,
                'tags': ', '.join(metadata.get('tags', [])),
                'dependencies': ', '.join(metadata.get('dependencies', [])),
                'description': metadata.get('description', ''),
                'performance_impact': metadata.get('performance_impact', 'unknown')
            })
        return pd.DataFrame(metadata_list)
    
    def clear_all_data(self):
        """Clear all stored data from applier and enrichments"""
        self._raw_dataframe = None
        self._enriched_dataframe = None
        self.enrichment_log.clear()
        self._enrichment_history.clear()
        
        for enrichment in self.enrichments:
            enrichment.clear_data()
        
        logger.info("Cleared all data from EnrichmentApplier and all enrichments")
    
    def apply_all_enrichments(self, df: pd.DataFrame) -> Dict[str, pd.DataFrame]:
        """
        Apply all enrichments to the input dataframe.
        
        Args:
            df: Input trade dataframe with Bond ID and ISIN columns
            
        Returns:
            Dictionary with 'raw' and 'enriched' dataframes
            
        Raises:
            EnrichmentDataError: If input dataframe is invalid
            EnrichmentProcessingError: If enrichment processing fails
        """
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            logger.info(f"Starting enrichment process with {len(self.enrichments)} enrichments")
            
            # Store raw data
            self._raw_dataframe = df.copy()
            current_df = df.copy()
            
            # Start with raw data
            result = {
                'raw': df.copy(),
                'enriched': df.copy()
            }
            
            successful_enrichments = []
            failed_enrichments = []
            
            # Apply each enrichment
            for enrichment in self.enrichments:
                logger.info(f"Applying {enrichment.name}")
                
                try:
                    enrichment_start_time = pd.Timestamp.now()
                    result['enriched'] = enrichment.apply_enrichment(result['enriched'])
                    enrichment_end_time = pd.Timestamp.now()
                    
                    # Record successful enrichment
                    self._enrichment_history.append({
                        'enrichment_name': enrichment.name,
                        'status': 'SUCCESS',
                        'start_time': enrichment_start_time,
                        'end_time': enrichment_end_time,
                        'duration': enrichment_end_time - enrichment_start_time,
                        'rows_processed': len(result['enriched']),
                        'enrichment_count': enrichment.enrichment_count
                    })
                    
                    successful_enrichments.append(enrichment.name)
                    
                    # Consolidate logs
                    for key, logs in enrichment.enrichment_log.items():
                        if key not in self.enrichment_log:
                            self.enrichment_log[key] = []
                        self.enrichment_log[key].extend(logs)
                        
                    logger.info(f"Successfully applied {enrichment.name}")
                    
                except Exception as e:
                    error_msg = f"Failed to apply {enrichment.name}: {str(e)}"
                    logger.error(error_msg)
                    
                    # Record failed enrichment
                    self._enrichment_history.append({
                        'enrichment_name': enrichment.name,
                        'status': 'FAILED',
                        'error_message': str(e),
                        'start_time': pd.Timestamp.now(),
                        'end_time': pd.Timestamp.now()
                    })
                    
                    failed_enrichments.append(enrichment.name)
                    continue
            
            # Store final enriched dataframe
            self._enriched_dataframe = result['enriched'].copy()
            
            logger.info(f"Enrichment process completed. "
                       f"Successful: {len(successful_enrichments)}, "
                       f"Failed: {len(failed_enrichments)}")
            
            if failed_enrichments:
                logger.warning(f"Failed enrichments: {', '.join(failed_enrichments)}")
            
            return result
            
        except Exception as e:
            if isinstance(e, (EnrichmentDataError, EnrichmentProcessingError)):
                raise
            raise EnrichmentProcessingError(f"Failed to apply enrichments: {str(e)}")
    
    def get_enrichment_summary(self) -> pd.DataFrame:
        """Get summary of all enrichments applied per ISIN"""
        summary_data = []
        
        for isin, logs in self.enrichment_log.items():
            for log_entry in logs:
                summary_data.append({
                    'ISIN': isin,
                    'Enrichment': log_entry['enrichment'],
                    'Status': log_entry['status'],
                    'Message': log_entry['message'],
                    'Timestamp': log_entry['timestamp']
                })
        
        return pd.DataFrame(summary_data)
    
    def get_enrichment_performance_summary(self) -> pd.DataFrame:
        """Get performance summary of enrichment operations"""
        return pd.DataFrame(self._enrichment_history)
    
    def get_overall_stats(self) -> Dict[str, Any]:
        """Get overall statistics about the enrichment process"""
        if not self._enrichment_history:
            return {}
        
        successful = [h for h in self._enrichment_history if h['status'] == 'SUCCESS']
        failed = [h for h in self._enrichment_history if h['status'] == 'FAILED']
        
        total_duration = sum([h.get('duration', pd.Timedelta(0)) for h in successful], pd.Timedelta(0))
        
        return {
            'total_enrichments_attempted': len(self._enrichment_history),
            'successful_enrichments': len(successful),
            'failed_enrichments': len(failed),
            'success_rate': len(successful) / len(self._enrichment_history) if self._enrichment_history else 0,
            'total_processing_time': total_duration,
            'average_processing_time': total_duration / len(successful) if successful else pd.Timedelta(0),
            'total_records_processed': len(self._enriched_dataframe) if self._enriched_dataframe is not None else 0,
            'total_enrichment_operations': self.total_enrichments_applied
        }


# =============================================================================
# REPORT CONFIGURATION TEMPLATES
# =============================================================================

class ReportConfigurations:
    """Predefined report configurations for common use cases"""
    
    @staticmethod
    def credit_risk_report() -> Dict[str, Any]:
        """Configuration for credit risk reports"""
        return {
            'required_enrichments': ['BondRatingEnrichment'],
            'optional_enrichments': ['CounterpartyEnrichment'],
            'tags': ['rating', 'credit', 'risk'],
            'exclude_tags': [],
            'performance_budget': 'medium',
            'description': 'Credit risk analysis with ratings and counterparty data'
        }
    
    @staticmethod
    def regulatory_capital_report() -> Dict[str, Any]:
        """Configuration for regulatory capital reports"""
        return {
            'required_enrichments': ['BondRatingEnrichment', 'AssetClassificationEnrichment'],
            'optional_enrichments': ['RegulatoryCapitalEnrichment'],
            'tags': ['regulatory', 'basel', 'classification'],
            'exclude_tags': ['pricing'],  # Exclude expensive pricing data
            'performance_budget': 'high',
            'description': 'Regulatory capital calculation with full classification'
        }
    
    @staticmethod
    def liquidity_analysis_report() -> Dict[str, Any]:
        """Configuration for liquidity analysis reports"""
        return {
            'required_enrichments': ['BondLiquidityAndHaircuts'],
            'optional_enrichments': ['BondRatingEnrichment'],
            'tags': ['liquidity', 'haircut', 'valuation'],
            'exclude_tags': ['counterparty'],
            'performance_budget': 'high',
            'description': 'Liquidity and haircut analysis for risk management'
        }
    
    @staticmethod
    def daily_portfolio_report() -> Dict[str, Any]:
        """Configuration for daily portfolio reports (fast, essential data only)"""
        return {
            'required_enrichments': ['AssetClassificationEnrichment'],
            'optional_enrichments': ['BondRatingEnrichment'],
            'tags': ['classification'],
            'exclude_tags': ['high_cost', 'pricing'],  # Exclude expensive operations
            'performance_budget': 'low',
            'description': 'Fast daily portfolio overview with basic classifications'
        }
    
    @staticmethod
    def comprehensive_analysis_report() -> Dict[str, Any]:
        """Configuration for comprehensive analysis (all enrichments)"""
        return {
            'required_enrichments': [],
            'optional_enrichments': [],
            'tags': [],  # Include all
            'exclude_tags': [],
            'performance_budget': 'high',
            'description': 'Complete analysis with all available enrichments'
        }
    
    @staticmethod
    def trading_desk_report() -> Dict[str, Any]:
        """Configuration for trading desk reports (pricing focused)"""
        return {
            'required_enrichments': ['PricingEnrichment'],
            'optional_enrichments': ['BondRatingEnrichment', 'BondLiquidityAndHaircuts'],
            'tags': ['pricing', 'valuation', 'liquidity'],
            'exclude_tags': ['regulatory'],
            'performance_budget': 'medium',
            'description': 'Trading-focused report with pricing and liquidity data'
        }


    
# =============================================================================
# BOND RATING ENRICHMENT
# =============================================================================

@register_enrichment(
    tags=['rating', 'credit', 'bond', 'risk'],
    dependencies=[],
    description="Enriches data with credit ratings from S&P, Moody's, and Fitch",
    performance_impact='medium'
)
class BondRatingEnrichment(AbstractEnrichment):
    """Enrichment class for bond credit ratings"""
    
    def __init__(self):
        super().__init__("BondRatingEnrichment")
        self.rating_mapper = RatingMapper()
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        """
        Load bond rating data from RefData database.
        
        Args:
            keys: List of ISINs or Bond IDs
            
        Returns:
            Dictionary with rating data per key
            
        Raises:
            ReferenceDataError: If rating data cannot be loaded
        """
        try:
            # Placeholder for actual database call
            # In real implementation, this would call your RefData wrapper functions
            logger.info(f"Loading rating data for {len(keys)} instruments")
            
            # Mock data structure that would come from your database
            rating_data = {}
            for key in keys:
                # This would be replaced with actual database call
                rating_data[key] = {
                    RatingAgency.SP.value: 'A+',
                    RatingAgency.MOODY.value: 'A1',
                    RatingAgency.FITCH.value: 'A+'
                }
            
            # Store the loaded reference data
            self._store_reference_data(rating_data)
            return rating_data
            
        except Exception as e:
            raise ReferenceDataError(f"Failed to load rating data: {str(e)}")
    
    def get_ratings_for_isins(self, isins: List[str], 
                             return_format: str = 'dataframe') -> Union[pd.DataFrame, Dict]:
        """
        Get comprehensive rating information for list of ISINs.
        
        Args:
            isins: List of ISIN identifiers
            return_format: 'dataframe' or 'dictionary'
            
        Returns:
            Rating information in requested format
            
        Raises:
            EnrichmentDataError: If ISIN list is invalid
            RatingCalculationError: If rating calculations fail
        """
        if not isins:
            raise EnrichmentDataError("ISIN list cannot be empty")
        
        try:
            rating_data = self.load_reference_data(isins)
            results = {}
            
            for isin in isins:
                if isin not in rating_data:
                    self._log_enrichment(isin, EnrichmentStatus.NO_DATA, "No rating data found")
                    continue
                    
                ratings = rating_data[isin]
                rating_summary = self._calculate_rating_summary(ratings)
                
                results[isin] = {
                    'isin': isin,
                    'sp_rating': ratings.get(RatingAgency.SP.value),
                    'moody_rating': ratings.get(RatingAgency.MOODY.value),
                    'fitch_rating': ratings.get(RatingAgency.FITCH.value),
                    'average_rating': rating_summary.average_rating.name if rating_summary.average_rating else None,
                    'best_rating': rating_summary.best_rating.name if rating_summary.best_rating else None,
                    'worst_rating': rating_summary.worst_rating.name if rating_summary.worst_rating else None,
                    'best_agency': rating_summary.best_agency.value if rating_summary.best_agency else None,
                    'worst_agency': rating_summary.worst_agency.value if rating_summary.worst_agency else None,
                    'rating_count': rating_summary.rating_count
                }
                
                self._log_enrichment(isin, EnrichmentStatus.SUCCESS, f"Processed {rating_summary.rating_count} ratings")
            
            if return_format.lower() == 'dataframe':
                return pd.DataFrame.from_dict(results, orient='index').reset_index(drop=True)
            else:
                return results
                
        except Exception as e:
            if isinstance(e, (EnrichmentDataError, ReferenceDataError)):
                raise
            raise RatingCalculationError(f"Failed to calculate ratings: {str(e)}")
    
    def _calculate_rating_summary(self, ratings: Dict[str, str]) -> RatingSummary:
        """Calculate rating statistics from agency ratings"""
        try:
            valid_ratings = []
            
            for agency_name, rating_str in ratings.items():
                if not rating_str or pd.isna(rating_str) or rating_str == 'NR':
                    continue
                    
                # Find matching agency enum
                agency = None
                for ag in RatingAgency:
                    if ag.value == agency_name:
                        agency = ag
                        break
                
                if agency:
                    normalized_rating = self.rating_mapper.normalize_rating(rating_str, agency)
                    if normalized_rating != RatingScale.NR:
                        valid_ratings.append(RatingInfo(
                            rating=normalized_rating,
                            agency=agency,
                            scale_value=self.rating_mapper.get_rating_hierarchy_value(normalized_rating)
                        ))
            
            if not valid_ratings:
                return RatingSummary(None, None, None, None, None, 0)
            
            # Calculate statistics
            scale_values = [r.scale_value for r in valid_ratings]
            avg_value = np.mean(scale_values)
            
            # Find closest rating to average
            avg_rating = min(valid_ratings, key=lambda x: abs(x.scale_value - avg_value)).rating
            
            # Best rating (lowest numerical value)
            best_rating_info = min(valid_ratings, key=lambda x: x.scale_value)
            
            # Worst rating (highest numerical value)
            worst_rating_info = max(valid_ratings, key=lambda x: x.scale_value)
            
            return RatingSummary(
                average_rating=avg_rating,
                best_rating=best_rating_info.rating,
                worst_rating=worst_rating_info.rating,
                best_agency=best_rating_info.agency,
                worst_agency=worst_rating_info.agency,
                rating_count=len(valid_ratings)
            )
            
        except Exception as e:
            raise RatingCalculationError(f"Failed to calculate rating summary: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        """Apply rating enrichment to trade dataframe"""
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
                
            if 'ISIN' not in df.columns:
                raise EnrichmentDataError("ISIN column not found in dataframe")
            
            # Store raw dataframe
            raw_df = df.copy()
            
            isins = df['ISIN'].dropna().unique().tolist()
            if not isins:
                logger.warning("No valid ISINs found in dataframe")
                self._store_dataframes(raw_df, df)
                return df
            
            rating_df = self.get_ratings_for_isins(isins, return_format='dataframe')
            
            # Merge with original dataframe
            enriched_df = df.merge(rating_df, left_on='ISIN', right_on='isin', how='left')
            
            # Store both dataframes
            self._store_dataframes(raw_df, enriched_df)
            
            return enriched_df
            
        except Exception as e:
            if isinstance(e, (EnrichmentDataError, RatingCalculationError, ReferenceDataError)):
                raise
            raise EnrichmentProcessingError(f"Failed to apply rating enrichment: {str(e)}")

# =============================================================================
# OTHER ENRICHMENT CLASSES (STUBS)
# =============================================================================

@register_enrichment(
    tags=['classification', 'asset', 'taxonomy'],
    dependencies=[],
    description="Enriches data with asset classification information",
    performance_impact='low'
)
class AssetClassificationEnrichment(AbstractEnrichment):
    """Enrichment for asset classification data"""
    
    def __init__(self):
        super().__init__("AssetClassificationEnrichment")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading asset classification data for {len(keys)} instruments")
            # Implementation would go here
            classification_data = {}
            self._store_reference_data(classification_data)
            return classification_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load asset classification data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            # Implementation would go here
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply asset classification enrichment: {str(e)}")


@register_enrichment(
    tags=['counterparty', 'entity', 'risk'],
    dependencies=[],
    description="Enriches data with counterparty information and risk metrics",
    performance_impact='medium'
)
class CounterpartyEnrichment(AbstractEnrichment):
    """Enrichment for counterparty data"""
    
    def __init__(self):
        super().__init__("CounterpartyEnrichment")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading counterparty data for {len(keys)} instruments")
            # Implementation would go here
            counterparty_data = {}
            self._store_reference_data(counterparty_data)
            return counterparty_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load counterparty data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            # Implementation would go here
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply counterparty enrichment: {str(e)}")


@register_enrichment(
    tags=['liquidity', 'haircut', 'risk', 'valuation'],
    dependencies=['BondRatingEnrichment'],  # Depends on ratings for calculation
    description="Enriches data with bond liquidity metrics and haircut calculations",
    performance_impact='high'
)
class BondLiquidityAndHaircuts(AbstractEnrichment):
    """Enrichment for bond liquidity and haircut data"""
    
    def __init__(self):
        super().__init__("BondLiquidityAndHaircuts")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading liquidity and haircut data for {len(keys)} instruments")
            # Implementation would go here
            liquidity_data = {}
            self._store_reference_data(liquidity_data)
            return liquidity_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load liquidity and haircut data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            # Implementation would go here
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply liquidity and haircuts enrichment: {str(e)}")


# Example of additional enrichments for different report types
@register_enrichment(
    tags=['pricing', 'valuation', 'market_data'],
    dependencies=[],
    description="Enriches data with real-time pricing information",
    performance_impact='high'
)
class PricingEnrichment(AbstractEnrichment):
    """Enrichment for pricing data"""
    
    def __init__(self):
        super().__init__("PricingEnrichment")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading pricing data for {len(keys)} instruments")
            pricing_data = {}
            self._store_reference_data(pricing_data)
            return pricing_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load pricing data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply pricing enrichment: {str(e)}")


@register_enrichment(
    tags=['regulatory', 'compliance', 'basel'],
    dependencies=['BondRatingEnrichment', 'AssetClassificationEnrichment'],
    description="Enriches data with regulatory capital calculations",
    performance_impact='medium'
)
class RegulatoryCapitalEnrichment(AbstractEnrichment):
    """Enrichment for regulatory capital calculations"""
    
    def __init__(self):
        super().__init__("RegulatoryCapitalEnrichment")
    
    def load_reference_data(self, keys: List[str]) -> Dict[str, Any]:
        try:
            logger.info(f"Loading regulatory capital data for {len(keys)} instruments")
            capital_data = {}
            self._store_reference_data(capital_data)
            return capital_data
        except Exception as e:
            raise ReferenceDataError(f"Failed to load regulatory capital data: {str(e)}")
    
    def apply_enrichment(self, df: pd.DataFrame) -> pd.DataFrame:
        try:
            if df is None or df.empty:
                raise EnrichmentDataError("Input dataframe is empty or None")
            
            raw_df = df.copy()
            enriched_df = df.copy()
            
            self._store_dataframes(raw_df, enriched_df)
            return enriched_df
        except Exception as e:
            if isinstance(e, EnrichmentDataError):
                raise
            raise EnrichmentProcessingError(f"Failed to apply regulatory capital enrichment: {str(e)}") 
        return df


# =============================================================================
# USAGE EXAMPLE
# =============================================================================

def example_usage():
    """Example of how to use the enhanced enrichment framework with report configurations"""
    
    try:
        # Sample trade data
        trade_data = pd.DataFrame({
            'TradeID': ['T001', 'T002', 'T003'],
            'ISIN': ['US123456789', 'GB987654321', 'DE555666777'],
            'BondID': ['B001', 'B002', 'B003'],
            'Quantity': [1000000, 2000000, 1500000],
            'Price': [99.5, 101.2, 98.8]
        })
        
        print("=== Enhanced Trade Data Enrichment Framework with Report Configurations ===\n")
        
        # Show all available enrichments and their metadata
        print("Available Enrichments:")
        all_metadata = EnrichmentFactory.get_all_metadata()
        for name, metadata in all_metadata.items():
            print(f"  {name}:")
            print(f"    Tags: {metadata.get('tags', [])}")
            print(f"    Dependencies: {metadata.get('dependencies', [])}")
            print(f"    Performance: {metadata.get('performance_impact', 'unknown')}")
            print(f"    Description: {metadata.get('description', 'No description')}")
            print()
        
        # Example 1: Using a predefined report configuration
        print("=== Example 1: Credit Risk Report Configuration ===")
        credit_config = ReportConfigurations.credit_risk_report()
        print(f"Report config: {credit_config}")
        
        applier_credit = EnrichmentApplier(report_config=credit_config)
        print(f"Selected enrichments: {applier_credit.enrichment_names}")
        
        # Show metadata for selected enrichments
        metadata_summary = applier_credit.get_enrichment_metadata_summary()
        print("\nSelected Enrichments Metadata:")
        print(metadata_summary)
        
        results_credit = applier_credit.apply_all_enrichments(trade_data)
        print(f"\nCredit Risk Report - Enrichments applied: {applier_credit.total_enrichments_applied}")
        
        # Example 2: Daily Portfolio Report (performance optimized)
        print("\n=== Example 2: Daily Portfolio Report (Performance Optimized) ===")
        daily_config = ReportConfigurations.daily_portfolio_report()
        print(f"Report config: {daily_config}")
        
        applier_daily = EnrichmentApplier(report_config=daily_config)
        print(f"Selected enrichments: {applier_daily.enrichment_names}")
        
        results_daily = applier_daily.apply_all_enrichments(trade_data)
        print(f"Daily Portfolio Report - Enrichments applied: {applier_daily.total_enrichments_applied}")
        
        # Example 3: Specific enrichments with dependency resolution
        print("\n=== Example 3: Specific Enrichments with Dependencies ===")
        specific_enrichments = ['BondLiquidityAndHaircuts']  # This has dependencies
        print(f"Requested: {specific_enrichments}")
        
        resolved = EnrichmentFactory.resolve_dependencies(specific_enrichments)
        print(f"Resolved with dependencies: {resolved}")
        
        applier_specific = EnrichmentApplier(enrichment_names=specific_enrichments)
        print(f"Applier created with: {applier_specific.enrichment_names}")
        
        # Example 4: Using tags to select enrichments
        print("\n=== Example 4: Tag-based Selection ===")
        rating_enrichments = EnrichmentFactory.get_enrichments_by_tags(['rating', 'credit'])
        print(f"Enrichments with 'rating' or 'credit' tags: {rating_enrichments}")
        
        liquidity_enrichments = EnrichmentFactory.get_enrichments_by_tags(['liquidity'], match_any=True)
        print(f"Enrichments with 'liquidity' tag: {liquidity_enrichments}")
        
        # Example 5: Custom report configuration
        print("\n=== Example 5: Custom Report Configuration ===")
        custom_config = {
            'required_enrichments': ['BondRatingEnrichment'],
            'tags': ['classification'],
            'exclude_tags': ['high_cost'],
            'performance_budget': 'medium',
            'description': 'Custom report with ratings and low-cost classifications'
        }
        
        applier_custom = EnrichmentApplier(report_config=custom_config)
        print(f"Custom config selected: {applier_custom.enrichment_names}")
        
        results_custom = applier_custom.apply_all_enrichments(trade_data)
        
        # Show performance comparison
        print("\n=== Performance Comparison ===")
        configs = [
            ("Credit Risk", applier_credit),
            ("Daily Portfolio", applier_daily),
            ("Custom", applier_custom)
        ]
        
        for name, applier in configs:
            stats = applier.get_overall_stats()
            print(f"{name} Report:")
            print(f"  Enrichments: {len(applier.enrichment_names)}")
            print(f"  Success Rate: {stats.get('success_rate', 0):.2%}")
            print(f"  Processing Time: {stats.get('total_processing_time', 'N/A')}")
            print()
        
        # Example 6: Error handling with missing enrichments
        print("=== Example 6: Error Handling ===")
        try:
            invalid_config = {
                'required_enrichments': ['NonExistentEnrichment'],
                'performance_budget': 'low'
            }
            EnrichmentApplier(report_config=invalid_config)
        except EnrichmentConfigurationError as e:
            print(f"Caught expected configuration error: {e}")
        
        # Example 7: All available report templates
        print("\n=== Example 7: All Available Report Templates ===")
        report_templates = {
            'Credit Risk': ReportConfigurations.credit_risk_report(),
            'Regulatory Capital': ReportConfigurations.regulatory_capital_report(),
            'Liquidity Analysis': ReportConfigurations.liquidity_analysis_report(),
            'Daily Portfolio': ReportConfigurations.daily_portfolio_report(),
            'Comprehensive': ReportConfigurations.comprehensive_analysis_report(),
            'Trading Desk': ReportConfigurations.trading_desk_report()
        }
        
        for template_name, config in report_templates.items():
            applier = EnrichmentApplier(report_config=config)
            print(f"{template_name}:")
            print(f"  Description: {config.get('description', 'No description')}")
            print(f"  Enrichments: {applier.enrichment_names}")
            print(f"  Performance Budget: {config.get('performance_budget', 'not specified')}")
            print()
            
    except Exception as e:
        print(f"Example failed with error: {str(e)}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    example_usage()
